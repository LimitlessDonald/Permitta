package permitta

import (
	"fmt"
	constants "gitlab.com/launchbeaver/permitta/constants"
	"reflect"
	"strings"
	"time"
)

// TODO create dart client of this , when its recieving permissions in json
// todo permission check order allowed or not by CRUDE - > not allowed by user->not allowed by role -> not allowed by group -> allowed by user-> allowed by role -> allowed by group -> then  time based limits starting with Batch

// Permission is a very important struct that can be used as an embedded struct to control permissions for just about anything or used as a type, of a struct field
type Permission struct {
	Create  bool `json:"create"`
	Read    bool `json:"read"`
	Update  bool `json:"update"`
	Delete  bool `json:"delete"`
	Execute bool `json:"execute"`

	// START CREATE FIELDS
	//UsersNotAllowedToCreate         []string `json:"usersNotAllowedToCreate" ` //slice list of users allowed to create current item, could be unique id , or username, doesn't matter
	//RolesNotAllowedToCreate         []string `json:"rolesNotAllowedToCreate"`
	//GroupsNotAllowedToCreate        []string `json:"groupsNotAllowedToCreate"`
	//DomainsNotAllowedToCreate       []string `json:"domainsNotAllowedToCreate"`
	//OrganizationsNotAllowedToCreate []string `json:"organizationsNotAllowedToCreate"`
	//
	//UsersAllowedToCreate         []string `json:"usersAllowedToCreate" ` //slice list of users allowed to create current item, could be unique id , or username, doesn't matter
	//RolesAllowedToCreate         []string `json:"rolesAllowedToCreate"`
	//GroupsAllowedToCreate        []string `json:"groupsAllowedToCreate"`
	//DomainsAllowedToCreate       []string `json:"domainsAllowedToCreate"`
	//OrganizationsAllowedToCreate []string `json:"organizationsAllowedToCreate"`

	CreateLimitAllTime        uint   `json:"createLimitAllTime"` // Can be used to control how many of an item can be stored . For example the total file size you can have stored at any time is 5GB , not to be confused with CreateLimitBatch
	CreateLimitBatch        uint   `json:"createLimitBatch"` // Can be used to limit how many of an item can be created at once, or at a time, for example limiting a user to adding 5 files at once . If this value is 5, the user won't be able to create more than 5 items at once
	CreateLimitPerMinute      uint   `json:"createLimitPerMinute"`
	CreateLimitPerHour        uint   `json:"createLimitPerHour"`
	CreateLimitPerDay         uint   `json:"createLimitPerDay"`
	CreateLimitPerWeek        uint   `json:"createLimitPerWeek"`
	CreateLimitPerFortnight   uint   `json:"createLimitPerFortnight"` //to limit items that can be created every two weeks
	CreateLimitPerMonth       uint   `json:"createLimitPerMonth"`     // Limit for every 30 days from FirstCreateTime  //todo, does it make sense to use FirstCreateTime or LastCreateTime
	CreateLimitPerQuarter     uint   `json:"createLimitPerQuarter"`   // 3 months, 90 days
	CreateLimitPerYear        uint   `json:"createLimitPerYear"`
	CreateLimitCustomDurations []string `json:"createLimitCustomDurations"` // can be used to control very fine-grained custom limit , it takes the form "per_uint_duration_uint" , e.g "per_5_minutes_2" . In this example, its means this operation is limited to only 2 every 5 minutes

	// END CREATE FIELDS

	// START READ FIELDS
	//UsersNotAllowedToRead         []string `json:"usersNotAllowedToRead" `
	//RolesNotAllowedToRead         []string `json:"rolesNotAllowedToRead"`
	//GroupsNotAllowedToRead        []string `json:"groupsNotAllowedToRead"`
	//DomainsNotAllowedToRead       []string `json:"domainsNotAllowedToRead"`
	//OrganizationsNotAllowedToRead []string `json:"organizationsNotAllowedToRead"`
	//
	//UsersAllowedToRead         []string `json:"usersAllowedToRead" `
	//RolesAllowedToRead         []string `json:"rolesAllowedToRead"`
	//GroupsAllowedToRead        []string `json:"groupsAllowedToRead"`
	//DomainsAllowedToRead       []string `json:"domainsAllowedToRead"`
	//OrganizationsAllowedToRead []string `json:"organizationsAllowedToRead"`

	ReadLimitAllTime        uint   `json:"readLimitAllTime"` // Can be used to control how many of an item can be stored . For example the total file size you can have stored at any time is 5GB , not to be confused with ReadLimitBatch
	ReadLimitBatch        uint   `json:"readLimitBatch"` // Can be used to limit how many of an item can be read at once, or at a time, for example limiting a user to adding 5 files at once . If this value is 5, the user won't be able to read more than 5 items at once
	ReadLimitPerMinute      uint   `json:"readLimitPerMinute"`
	ReadLimitPerHour        uint   `json:"readLimitPerHour"`
	ReadLimitPerDay         uint   `json:"readLimitPerDay"`
	ReadLimitPerWeek        uint   `json:"readLimitPerWeek"`
	ReadLimitPerFortnight   uint   `json:"readLimitPerFortnight"` //to limit items that can be read every two weeks
	ReadLimitPerMonth       uint   `json:"readLimitPerMonth"`     // Limit for every 30 days from FirstReadTime  //todo, does it make sense to use FirstReadTime or LastReadTime
	ReadLimitPerQuarter     uint   `json:"readLimitPerQuarter"`   // 3 months, 90 days
	ReadLimitPerYear        uint   `json:"readLimitPerYear"`
	ReadLimitCustomDurations []string `json:"readLimitCustomDurations"` // can be used to control very fine-grained custom limit , it takes the form "per_uint_duration_uint" , e.g "per_5_minutes_2" . In this example, its means this operation is limited to only 2 every 5 minutes

	// END READ FIELDS

	// START UPDATE FIELDS
	//UsersNotAllowedToUpdate         []string `json:"usersNotAllowedToUpdate" `
	//RolesNotAllowedToUpdate         []string `json:"rolesNotAllowedToUpdate"`
	//GroupsNotAllowedToUpdate        []string `json:"groupsNotAllowedToUpdate"`
	//DomainsNotAllowedToUpdate       []string `json:"domainsNotAllowedToUpdate"`
	//OrganizationsNotAllowedToUpdate []string `json:"organizationsNotAllowedToUpdate"`
	//
	//UsersAllowedToUpdate         []string `json:"usersAllowedToUpdate" `
	//RolesAllowedToUpdate         []string `json:"rolesAllowedToUpdate"`
	//GroupsAllowedToUpdate        []string `json:"groupsAllowedToUpdate"`
	//DomainsAllowedToUpdate       []string `json:"domainsAllowedToUpdate"`
	//OrganizationsAllowedToUpdate []string `json:"organizationsAllowedToUpdate"`

	UpdateLimitAllTime        uint   `json:"updateLimitAllTime"` // Can be used to control how many of an item can be stored . For example the total file size you can have stored at any time is 5GB , not to be confused with UpdateLimitBatch
	UpdateLimitBatch        uint   `json:"updateLimitBatch"` // Can be used to limit how many of an item can be updated at once, or at a time, for example limiting a user to adding 5 files at once . If this value is 5, the user won't be able to update more than 5 items at once
	UpdateLimitPerMinute      uint   `json:"updateLimitPerMinute"`
	UpdateLimitPerHour        uint   `json:"updateLimitPerHour"`
	UpdateLimitPerDay         uint   `json:"updateLimitPerDay"`
	UpdateLimitPerWeek        uint   `json:"updateLimitPerWeek"`
	UpdateLimitPerFortnight   uint   `json:"updateLimitPerFortnight"` //to limit items that can be updated every two weeks
	UpdateLimitPerMonth       uint   `json:"updateLimitPerMonth"`     // Limit for every 30 days from FirstUpdateTime  //todo, does it make sense to use FirstUpdateTime or LastUpdateTime
	UpdateLimitPerQuarter     uint   `json:"updateLimitPerQuarter"`   // 3 months, 90 days
	UpdateLimitPerYear        uint   `json:"updateLimitPerYear"`
	UpdateLimitCustomDurations []string `json:"updateLimitCustomDurations"` // can be used to control very fine-grained custom limit , it takes the form "per_uint_duration_uint" , e.g "per_5_minutes_2" . In this example, its means this operation is limited to only 2 every 5 minutes

	// END UPDATE FIELDS

	// START DELETE FIELDS
	//UsersNotAllowedToDelete         []string `json:"usersNotAllowedToDelete" `
	//RolesNotAllowedToDelete         []string `json:"rolesNotAllowedToDelete"`
	//GroupsNotAllowedToDelete        []string `json:"groupsNotAllowedToDelete"`
	//DomainsNotAllowedToDelete       []string `json:"domainsNotAllowedToDelete"`
	//OrganizationsNotAllowedToDelete []string `json:"organizationsNotAllowedToDelete"`
	//
	//UsersAllowedToDelete         []string `json:"usersAllowedToDelete" `
	//RolesAllowedToDelete         []string `json:"rolesAllowedToDelete"`
	//GroupsAllowedToDelete        []string `json:"groupsAllowedToDelete"`
	//DomainsAllowedToDelete       []string `json:"domainsAllowedToDelete"`
	//OrganizationsAllowedToDelete []string `json:"organizationsAllowedToDelete"`

	DeleteLimitAllTime        uint   `json:"deleteLimitAllTime"` // Can be used to control how many of an item can be stored . For example the total file size you can have stored at any time is 5GB , not to be confused with DeleteLimitBatch
	DeleteLimitBatch        uint   `json:"deleteLimitBatch"` // Can be used to limit how many of an item can be deleted at once, or at a time, for example limiting a user to adding 5 files at once . If this value is 5, the user won't be able to delete more than 5 items at once
	DeleteLimitPerMinute      uint   `json:"deleteLimitPerMinute"`
	DeleteLimitPerHour        uint   `json:"deleteLimitPerHour"`
	DeleteLimitPerDay         uint   `json:"deleteLimitPerDay"`
	DeleteLimitPerWeek        uint   `json:"deleteLimitPerWeek"`
	DeleteLimitPerFortnight   uint   `json:"deleteLimitPerFortnight"` //to limit items that can be deleted every two weeks
	DeleteLimitPerMonth       uint   `json:"deleteLimitPerMonth"`     // Limit for every 30 days from FirstDeleteTime  //todo, does it make sense to use FirstDeleteTime or LastDeleteTime
	DeleteLimitPerQuarter     uint   `json:"deleteLimitPerQuarter"`   // 3 months, 90 days
	DeleteLimitPerYear        uint   `json:"deleteLimitPerYear"`
	DeleteLimitCustomDurations []string `json:"deleteLimitCustomDurations"` // can be used to control very fine-grained custom limit , it takes the form "per_uint_duration_uint" , e.g "per_5_minutes_2" . In this example, its means this operation is limited to only 2 every 5 minutes

	// END DELETE FIELDS

	// START EXECUTE FIELDS
	//UsersNotAllowedToExecute         []string `json:"usersNotAllowedToExecute" `
	//RolesNotAllowedToExecute         []string `json:"rolesNotAllowedToExecute"`
	//GroupsNotAllowedToExecute        []string `json:"groupsNotAllowedToExecute"`
	//DomainsNotAllowedToExecute       []string `json:"domainsNotAllowedToExecute"`
	//OrganizationsNotAllowedToExecute []string `json:"organizationsNotAllowedToExecute"`
	//
	//UsersAllowedToExecute         []string `json:"usersAllowedToExecute" `
	//RolesAllowedToExecute         []string `json:"rolesAllowedToExecute"`
	//GroupsAllowedToExecute        []string `json:"groupsAllowedToExecute"`
	//DomainsAllowedToExecute       []string `json:"domainsAllowedToExecute"`
	//OrganizationsAllowedToExecute []string `json:"organizationsAllowedToExecute"`

	ExecuteLimitAllTime        uint   `json:"executeLimitAllTime"` // Can be used to control how many of an item can be stored . For example the total file size you can have stored at any time is 5GB , not to be confused with ExecuteLimitBatch
	ExecuteLimitBatch        uint   `json:"executeLimitBatch"` // Can be used to limit how many of an item can be executed at once, or at a time, for example limiting a user to adding 5 files at once . If this value is 5, the user won't be able to execute more than 5 items at once
	ExecuteLimitPerMinute      uint   `json:"executeLimitPerMinute"`
	ExecuteLimitPerHour        uint   `json:"executeLimitPerHour"`
	ExecuteLimitPerDay         uint   `json:"executeLimitPerDay"`
	ExecuteLimitPerWeek        uint   `json:"executeLimitPerWeek"`
	ExecuteLimitPerFortnight   uint   `json:"executeLimitPerFortnight"` //to limit items that can be executed every two weeks
	ExecuteLimitPerMonth       uint   `json:"executeLimitPerMonth"`     // Limit for every 30 days from FirstExecuteTime  //todo, does it make sense to use FirstExecuteTime or LastExecuteTime
	ExecuteLimitPerQuarter     uint   `json:"executeLimitPerQuarter"`   // 3 months, 90 days
	ExecuteLimitPerYear        uint   `json:"executeLimitPerYear"`
	ExecuteLimitCustomDurations []string `json:"executeLimitCustomDurations"` // can be used to control very fine-grained custom limit , it takes the form "per_uint_duration_uint" , e.g "per_5_minutes_2" . In this example, its means this operation is limited to only 2 every 5 minutes

	// END EXECUTE FIELDS

}

type OperationLimits struct{
	AllTimeLimit        uint   `json:"allTimeLimit"` // Can be used to control how many of an item can be stored . For example the total file size you can have stored at any time is 5GB , not to be confused with DeleteLimitBatch
	BatchLimit        uint   `json:"batchLimit"` // Can be used to limit how many of an item can be deleted at once, or at a time, for example limiting a user to adding 5 files at once . If this value is 5, the user won't be able to delete more than 5 items at once
	PerMinuteLimit      uint   `json:"perMinuteLimit"`
	PerHourLimit        uint   `json:"perHourLimit"`
	PerDayLimit         uint   `json:"perDayLimit"`
	PerWeekLimit        uint   `json:"perWeekLimit"`
	PerFortnightLimit   uint    `json:"perFortnightLimit"` //to limit items that can be deleted every two weeks
	PerMonthLimit       uint     `json:"perMonthLimit"`  // Limit for every 30 days from FirstDeleteTime  //todo, does it make sense to use FirstDeleteTime or LastDeleteTime
	PerQuarterLimit     uint    `json:"perQuarterLimit"`// 3 months, 90 days
	PerYearLimit        uint   `json:"perYearLimit"`
	CustomDurationsLimit []string `json:"customDurationsLimit"` 
	
}

type PermissionUsage struct {
	// START CREATE FIELDS
	FirstCreateTime                         time.Time `json:"firstCreateTime"`
	LastCreateTime                          time.Time `json:"lastCreateTime"`
	LastCreateQuantity                      uint      `json:"lastCreateQuantity"`
	TotalCreatedAllTime         uint `json:"totalCreatedAllTime"`
	TotalCreatedWithinTheLastMinute         uint      `json:"totalCreatedWithinTheLastMinute"`
	TotalCreatedWithinTheLastHour           uint      `json:"totalCreatedWithinTheLastHour"`
	TotalCreatedWithinTheLastDay            uint      `json:"totalCreatedWithinTheLastDay"`
	TotalCreatedWithinTheLastWeek           uint      `json:"totalCreatedWithinTheLastWeek"`
	TotalCreatedWithinTheLastFortnight      uint      `json:"totalCreatedWithinTheLastFortnight"`
	TotalCreatedWithinTheLastMonth          uint      `json:"totalCreatedWithinTheLastMonth"`
	TotalCreatedWithinTheLastQuarter        uint      `json:"totalCreatedWithinTheLastQuarter"`
	TotalCreatedWithinTheLastYear           uint      `json:"totalCreatedWithinTheLastYear"`
	TotalCreatedWithinTheLastCustomDurations []string    // can be used to record usage that happened within a custom time frame it takes the form "last_uint_duration_uint" e.g "last_10_minutes_4" . In this example, it means, this operation has been used 4 times in the last 10 minutes
	//END CREATE FIELDS

	//START READ FIELDS
	FirstReadTime                        time.Time `json:"firstReadTime"`
	LastReadTime                         time.Time `json:"lastReadTime"`
	LastReadQuantity                     uint      `json:"lastReadQuantity"`
	TotalReadAllTime uint `json:"totalReadAllTime"`
	TotalReadWithinTheLastMinute         uint      `json:"totalReadWithinTheLastMinute"`
	TotalReadWithinTheLastHour           uint      `json:"totalReadWithinTheLastHour"`
	TotalReadWithinTheLastDay            uint      `json:"totalReadWithinTheLastDay"`
	TotalReadWithinTheLastWeek           uint      `json:"totalReadWithinTheLastWeek"`
	TotalReadWithinTheLastFortnight      uint      `json:"totalReadWithinTheLastFortnight"`
	TotalReadWithinTheLastMonth          uint      `json:"totalReadWithinTheLastMonth"`
	TotalReadWithinTheLastQuarter        uint      `json:"totalReadWithinTheLastQuarter"`
	TotalReadWithinTheLastYear           uint      `json:"totalReadWithinTheLastYear"`
	TotalReadWithinTheLastCustomDurations []string    // can be used to record usage that happened within a custom time frame it takes the form "last_uint_duration_uint" e.g "last_10_minutes_4" . In this example, it means, this operation has been used 4 times in the last 10 minutes
	//END READ FIELDS

	// START UPDATE FIELDS
	FirstUpdateTime                         time.Time `json:"firstUpdateTime"`
	LastUpdateTime                          time.Time `json:"lastUpdateTime"`
	LastUpdateQuantity                      uint      `json:"lastUpdateQuantity"`
	TotalUpdatedAllTime uint  `json:"totalUpdatedAllTime"`
	TotalUpdatedWithinTheLastMinute         uint      `json:"totalUpdatedWithinTheLastMinute"`
	TotalUpdatedWithinTheLastHour           uint      `json:"totalUpdatedWithinTheLastHour"`
	TotalUpdatedWithinTheLastDay            uint      `json:"totalUpdatedWithinTheLastDay"`
	TotalUpdatedWithinTheLastWeek           uint      `json:"totalUpdatedWithinTheLastWeek"`
	TotalUpdatedWithinTheLastFortnight      uint      `json:"totalUpdatedWithinTheLastFortnight"`
	TotalUpdatedWithinTheLastMonth          uint      `json:"totalUpdatedWithinTheLastMonth"`
	TotalUpdatedWithinTheLastQuarter        uint      `json:"totalUpdatedWithinTheLastQuarter"`
	TotalUpdatedWithinTheLastYear           uint      `json:"totalUpdatedWithinTheLastYear"`
	TotalUpdatedWithinTheLastCustomDurations []string    // can be used to record usage that happened within a custom time frame it takes the form "last_uint_duration_uint" e.g "last_10_minutes_4" . In this example, it means, this operation has been used 4 times in the last 10 minutes
	//END UPDATE FIELDS

	//START DELETE FIELDS
	FirstDeleteTime                         time.Time `json:"firstDeleteTime"`
	LastDeleteTime                          time.Time `json:"lastDeleteTime"`
	LastDeleteQuantity                      uint      `json:"lastDeleteQuantity"`
	TotalDeletedAllTime uint `json:"totalDeletedAllTime"`
	TotalDeletedWithinTheLastMinute         uint      `json:"totalDeletedWithinTheLastMinute"`
	TotalDeletedWithinTheLastHour           uint      `json:"totalDeletedWithinTheLastHour"`
	TotalDeletedWithinTheLastDay            uint      `json:"totalDeletedWithinTheLastDay"`
	TotalDeletedWithinTheLastWeek           uint      `json:"totalDeletedWithinTheLastWeek"`
	TotalDeletedWithinTheLastFortnight      uint      `json:"totalDeletedWithinTheLastFortnight"`
	TotalDeletedWithinTheLastMonth          uint      `json:"totalDeletedWithinTheLastMonth"`
	TotalDeletedWithinTheLastQuarter        uint      `json:"totalDeletedWithinTheLastQuarter"`
	TotalDeletedWithinTheLastYear           uint      `json:"totalDeletedWithinTheLastYear"`
	TotalDeletedWithinTheLastCustomDurations []string    // can be used to record usage that happened within a custom time frame it takes the form "last_uint_duration_uint" e.g "last_10_minutes_4" . In this example, it means, this operation has been used 4 times in the last 10 minutes
	//END DELETE FIELDS

	//START EXECUTE FIELDS
	FirstExecuteTime                         time.Time `json:"firstExecuteTime"`
	LastExecuteTime                          time.Time `json:"lastExecuteTime"`
	LastExecuteQuantity                      uint      `json:"lastExecuteQuantity"`
	TotalExecutedAllTime uint `json:"totalExecutedAllTime"`
	TotalExecutedWithinTheLastMinute         uint      `json:"totalExecutedWithinTheLastMinute"`
	TotalExecutedWithinTheLastHour           uint      `json:"totalExecutedWithinTheLastHour"`
	TotalExecutedWithinTheLastDay            uint      `json:"totalExecutedWithinTheLastDay"`
	TotalExecutedWithinTheLastWeek           uint      `json:"totalExecutedWithinTheLastWeek"`
	TotalExecutedWithinTheLastFortnight      uint      `json:"totalExecutedWithinTheLastFortnight"`
	TotalExecutedWithinTheLastMonth          uint      `json:"totalExecutedWithinTheLastMonth"`
	TotalExecutedWithinTheLastQuarter        uint      `json:"totalExecutedWithinTheLastQuarter"`
	TotalExecutedWithinTheLastYear           uint      `json:"totalExecutedWithinTheLastYear"`
	TotalExecutedWithinTheLastCustomDurations []string    // can be used to record usage that happened within a custom time frame it takes the form "last_uint_duration_uint" e.g "last_10_minutes_4" . In this example, it means, this operation has been used 4 times in the last 10 minutes
	//END EXECUTE FIELDS

}

// PermissionRequestData is a struct that holds data concerning the permission request . It includes things like users,roles,groups,operation(constants.OperationCreate|constants.OperationRead....) etc. necessary to help get permission status
type PermissionRequestData struct {
	Operation              string
	UserEntityPermissions   Permission
	RoleEntityPermissions   Permission
	GroupEntityPermissions  Permission
	DomainEntityPermissions Permission
	OrgEntityPermissions    Permission //Organization EntityPermissions
	PermissionOrder         string     // the flow in which the permission should take e.g org->domain->group->role->user //default order is org->
}

// PermissionWithUsageRequestData to hold permission data and also check permission against usage and limits, so if operationQuantity + usage exceeds limit, deny access, but if its less or equal to grant access, hope you get the gist
type PermissionWithUsageRequestData struct {
	PermissionRequestData
	OperationQuantity    uint
	UserEntityUsage   PermissionUsage
	RoleEntityUsage   PermissionUsage
	GroupEntityUsage  PermissionUsage
	DomainEntityUsage PermissionUsage
	OrgEntityUsage    PermissionUsage
}

func IsOperationPermitted(permissionRequestData PermissionRequestData) bool {
	operation := permissionRequestData.Operation
	permissionOrder := getPermissionOrder(permissionRequestData.PermissionOrder)
	var permissions Permission
	var emptyPermission Permission
	finalPermittedValue := false

	// only allow CRUDE(Create, Read, Update, Delete,Execute) operations
	if isOperationValid(operation) == false {
		fmt.Println("Invalid operation")
		return false
	}

	// let's split the order and loop through it to get each entity operation permission,

	// ensure the order contains the separator first , before attempting to split
	if len(permissionOrder) >= constants.MinimumPermissionOrderLength && strings.Contains(permissionOrder, constants.OrderSeparator) {
		splitOrder := strings.Split(permissionOrder, constants.OrderSeparator)
		if len(splitOrder) > 0 {
			//loop through the split order and check permission for each entity as arranged in the order
			for i := 0; i < len(splitOrder); i++ {
				currentEntity := splitOrder[i]
				// if any of the entity is invalid at any point decline permission
				if isEntityValid(currentEntity) == false {
					fmt.Printf("Invalid entity : %s",currentEntity)
					return false
				}

				permissions = getEntityPermission(currentEntity, permissionRequestData)
				// check if permissions is empty, if its empty continue
				if permissions == emptyPermission {
					continue
				}

				isCurrentEntityPermitted := IsEntityOperationPermitted(operation, permissions)
				if isCurrentEntityPermitted == false {
					return false
				}
				// if current entity is permitted, and we are not on the last entity in the order, continue
				if (isCurrentEntityPermitted == true) && (i != len(splitOrder)-1) {
					// its important we set final permitted to true here, because if this entity operation in the order is filled and permitted , but all other proceeding entity Permission struct are empty, it would give a wrong result
					//So we need to save current permission value as true , in case other permission data are empty
					// NOTE that empty is not same as false, if the operation we are checking for proceeding permission structs is not empty and marked as false, the condition above would return false
					finalPermittedValue = true
					continue
				}
				// if current entity is permitted, and it's the last entity in the order, return true
				if (isCurrentEntityPermitted == true) && (i == len(splitOrder)-1) {
					return true
				}
			}
		}
	}

	fmt.Println("Hala 1")
	return finalPermittedValue
}

//todo [LATER] optimise this function , its looping through the permissions twice

// IsOperationPermittedWithUsage is a function to check if operation is permitted, then it checks the usage following the PermissionRequestData.PermissionOrder
// It loops through each entity in the order and checks permission against request usage + operationQuantity for each limit type
// WHat does this mean let's say our request data is like this :
/**
 data:= PermissionWithUsageRequestData  {
	PermissionRequestData : PermissionRequestData {
			Operation : "create"
			UserEntityPermissions: userPermission
			RoleEntityPermissions :  rolePermission
			GroupEntityPermissions:  Permission
			DomainEntityPermissions Permission
			OrgEntityPermissions    Permission //Organization Permissions
			PermissionOrder   string
		}
	OperationQuantity uint
	Usage          PermissionUsage
}

*/
func IsOperationPermittedWithUsage(requestData PermissionWithUsageRequestData) bool {
	operationQuantity:=requestData.OperationQuantity
	var limitFieldPrefix string
	var usageTotalFieldInfix string
	//var firstTimeField string
	//var lastTimeField string
	//var lastQuantityField string
	var entityPermissions Permission
	var entityUsage PermissionUsage

	permissionOrder := getPermissionOrder(requestData.PermissionOrder)
	// first check if operation is permitted based on the operation
	isOperationPermitted := IsOperationPermitted(requestData.PermissionRequestData)
	if isOperationPermitted == false {
		return false
	}

	if requestData.Operation == constants.OperationCreate {
		limitFieldPrefix = "Create"
		usageTotalFieldInfix="Created"

		//firstTimeField = "FirstCreateTime"
		//lastTimeField = "LastCreateTime"
		//lastQuantityField = "LastCreateQuantity"
	}
	if requestData.Operation == constants.OperationRead {
		limitFieldPrefix = "Read"
		usageTotalFieldInfix="Read"

		//firstTimeField = "FirstReadTime"
		//lastTimeField = "LastReadTime"
		//lastQuantityField = "LastReadQuantity"
	}
	if requestData.Operation == constants.OperationUpdate {
		limitFieldPrefix = "Update"
		usageTotalFieldInfix="Updated"

		//firstTimeField = "FirstUpdateTime"
		//lastTimeField = "LastUpdateTime"
		//lastQuantityField = "LastUpdateQuantity"
	}

	if requestData.Operation == constants.OperationDelete {
		limitFieldPrefix = "Delete"
		usageTotalFieldInfix="Deleted"

		//firstTimeField = "FirstDeleteTime"
		//lastTimeField = "LastDeleteTime"
		//lastQuantityField = "LastDeleteQuantity"
	}

	if requestData.Operation == constants.OperationExecute {
		limitFieldPrefix = "Execute"
		usageTotalFieldInfix="Executed"

		//firstTimeField = "FirstExecuteTime"
		//lastTimeField = "LastExecuteTime"
		//lastQuantityField = "LastExecuteQuantity"
	}

	
	// Now let's define and concat the limit fields first 
	limitAllTimeField:=limitFieldPrefix+"LimitAllTime"
	limitBatchField:=limitFieldPrefix+"LimitBatch"
	limitPerMinuteField:=limitFieldPrefix+"LimitPerMinute"
	limitPerHourField:=limitFieldPrefix+"LimitPerHour"
	limitPerDayField:=limitFieldPrefix+"LimitPerDay"
	limitPerWeekField:=limitFieldPrefix+"LimitPerWeek"
	limitPerFortnightField:=limitFieldPrefix+"LimitPerFortnight"
	limitPerMonthField:=limitFieldPrefix+"LimitPerMonth"
	limitPerQuarterField:=limitFieldPrefix+"LimitPerQuarter"
	limitPerYearField:=limitFieldPrefix+"LimitPerYear"
	//limitCustomDurationsField:=limitFieldPrefix+"LimitCustomDurations"


	// define and concat usage fields
	totalUsageAllTime:="Total"+usageTotalFieldInfix+"AllTime"
	totalUsageWithinTheLastMinuteField:="Total"+usageTotalFieldInfix+"WithinTheLastMinute"
	totalUsageWithinTheLastHourField:="Total"+usageTotalFieldInfix+"WithinTheLastHour"
	totalUsageWithinTheLastDayField:="Total"+usageTotalFieldInfix+"WithinTheLastDay"
	totalUsageWithinTheLastWeekField:="Total"+usageTotalFieldInfix+"WithinTheLastWeek"
	totalUsageWithinTheLastFortnightField:="Total"+usageTotalFieldInfix+"WithinTheLastFortnight"
	totalUsageWithinTheLastMonthField:="Total"+usageTotalFieldInfix+"WithinTheLastMonth"
	totalUsageWithinTheLastQuarterField:="Total"+usageTotalFieldInfix+"WithinTheLastQuarter"
	totalUsageWithinTheLastYearField:="Total"+usageTotalFieldInfix+"WithinTheLastYear"
	//totalUsageWithinTheLastCustomDurationsField:="Total"+usageTotalFieldInfix+"WithinTheLastCustomDurations"




	// Loop through all the usage according to the entity order
	// compare each operation quantity + usage , if the addition is more than its appropriate limit deny access
	// for example, if I am doing a creating 5 files batch , it loops through all the entity's and the limit, it first checks the "batch" limit, if the limit for "batch" is less or equal to 5 continue,
	// following the order, within that same order, it checks all other limits against the usage, if the usage + operation quantity exceeds the corresponding limit, deny access
	if isOperationPermitted == true {

		if len(permissionOrder) >= constants.MinimumPermissionOrderLength && strings.Contains(permissionOrder, constants.OrderSeparator) {
			splitOrder := strings.Split(permissionOrder, constants.OrderSeparator)
			if len(splitOrder) > 0 {
				for i := 0; i < len(splitOrder); i++ {
					currentEntity := splitOrder[i]
					// if any of the entity is invalid at any point decline permission
					if isEntityValid(currentEntity) == false {
						fmt.Printf("Invalid entity : %s",currentEntity)
						return false
					}

					// Get current entity permission
					entityPermissions=getEntityPermission(currentEntity,requestData.PermissionRequestData)
					// Get entity usage
					entityUsage=getEntityPermissionUsage(currentEntity,requestData)

					// Now let's get values of the various fields we need for the current operation we are checking permission for

					// Let's start with limits
					limitAllTimeValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitAllTimeField)
					limitBatchValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitBatchField)
					limitPerMinuteValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitPerMinuteField)
					limitPerHourValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitPerHourField)
					limitPerDayValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitPerDayField)
					limitPerWeekValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitPerWeekField)
					limitPerFortnightValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitPerFortnightField)
					limitPerMonthValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitPerMonthField)
					limitPerQuarterValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitPerQuarterField)
					limitPerYearValue, _ :=getUintValueFromStructFieldByName(entityPermissions,limitPerYearField)
					//limitCustomDurationsValue, _ :=getStringSliceValueFromStructFieldByName(entityPermissions,limitCustomDurationsField)

					// Let's get usage values

					usageAllTimeValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageAllTime)
					usageWithinMinuteValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastMinuteField)
					usageWithinHourValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastHourField)
					usageWithinDayValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastDayField)
					usageWithinWeekValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastWeekField)
					usageWithinFortnightValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastFortnightField)
					usageWithinMonthValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastMonthField)
					usageWithinQuarterValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastQuarterField)
					usageWithinYearValue,_:= getUintValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastYearField)
					//usageWithinCustomDurationsValue,_:= getStringSliceValueFromStructFieldByName(entityUsage,totalUsageWithinTheLastCustomDurationsField)

					// special error message for batch value, because it can't be 0, it needs to be at least 1, this is to protect the user of permitta, forcing them to set a batch limit
					if limitBatchValue<1 {
						fmt.Printf("%s value for %s entity has to be at least 1  \n",limitBatchField,currentEntity)
						return false
					}
					// if any of the limit values is less than 0, deny permission, because that's not normal, I have taken precaution to prevent this, but just in case there is a scenario, I didn't consider that made invalid value slip through 
					if limitAllTimeValue<0 ||
						limitPerMinuteValue<0 ||
						limitPerHourValue<0 ||
						limitPerDayValue<0 ||
						limitPerWeekValue<0 ||
						limitPerFortnightValue<0 ||
						limitPerMonthValue<0 ||
						limitPerQuarterValue<0 ||
						limitPerYearValue<0 {
						fmt.Printf("Invalid limit value \n Check all your %s entity permission limit values to ensure they are all valid, none of them should be less than 0 \n",currentEntity)
						return false 
					}

					if usageAllTimeValue<0 ||
						usageWithinMinuteValue<0 ||
						usageWithinHourValue<0 ||
						usageWithinDayValue<0 ||
						usageWithinWeekValue<0 ||
						usageWithinFortnightValue<0 ||
						usageWithinMonthValue<0 ||
						usageWithinQuarterValue<0 ||
						usageWithinYearValue<0 {
						fmt.Printf("Invalid limit value \n Check all your %s entity permission limit values to ensure they are all valid, none of them should be less than 0 \n",currentEntity)
						return false
					}
					// todo if any of the limit values or usage values is -1 or less than 0 deny access because something is not normal , they should be uint values


					// TODO Document that batch limit is a compulsory field to fill, its slightly different from every other limit  where 0  denotes unlimited . If batch limit for any operation is left at the default struct field of 0 the permission request would FAIL, the whole point is to protect anyone who uses permitta from a spamming, where
					// TODO CONTD - where users try to perform too many operations at once

					// if limitBatchB
					// First check ^LimitBatch is not exceeded , if its exceeded deny permission, there is no need to check the next order
					// Also if fore some reason limitBatchValue is -1 , this is not a valid value, so deny permission
					// limitBatchValue is not like other limits where 0 denotes unlimited, this forces any permitta user to set a strict batch limit value
					if operationQuantity>limitBatchValue{
						return false
					}


					// Next let's check all time limit for current entity, and deny access if exceeded
					// to do that , we ensure operation quantity + all time usage doesn't exceed all time limit , and the all-time limit value isn't unlimited =0
					if (operationQuantity+usageAllTimeValue > limitAllTimeValue) && limitAllTimeValue!=constants.Unlimited{
						return false
					}

					// next check per minute limit
					if (operationQuantity+usageWithinMinuteValue > limitPerMinuteValue) && limitPerMinuteValue!=constants.Unlimited{
						return false
					}

					// next check per hour limit
					if (operationQuantity+usageWithinHourValue > limitPerHourValue) && limitPerHourValue!=constants.Unlimited{
						return false
					}

					// next check per day limit
					if (operationQuantity+usageWithinDayValue > limitPerDayValue) && limitPerDayValue!=constants.Unlimited{
						return false
					}

					// next check per week limit
					if (operationQuantity+usageWithinWeekValue > limitPerWeekValue) && limitPerWeekValue!=constants.Unlimited{
						return false
					}

					// next check per fortnight limit
					if (operationQuantity+usageWithinFortnightValue > limitPerFortnightValue) && limitPerFortnightValue!=constants.Unlimited{
						return false
					}

					// next check per month limit
					if (operationQuantity+usageWithinMonthValue > limitPerMonthValue) && limitPerMonthValue!=constants.Unlimited{
						return false
					}


					// next check per quarter limit
					if (operationQuantity+usageWithinQuarterValue > limitPerQuarterValue) && limitPerQuarterValue!=constants.Unlimited{
						return false
					}


					// next check per year limit
					if (operationQuantity+usageWithinYearValue > limitPerYearValue) && limitPerYearValue!=constants.Unlimited{
						return false
					}

					// todo come and add custom durations limit check

					// if all checks passed up till this point , that me and permission is granted for this entity , so continue to the next entity,
					// but if the entity we just ran check for is the last entity, then it means permission is granted , else continue to next entity
					if i == len(splitOrder)-1{
						// this is the last entity in the order
						// this means all checks in the last entity went well if we go to this point
						return true

					}else{
						// this means current entity checks went well, but we are not in the last entity in the order yet, so let's move to the next entity to check if limits are not exceeded
						continue
					}
				}
			}

		}

	}

	return false
}

func IsEntityOperationPermitted(operation string, entityPermissions Permission) bool {
	// ensure the operation is correct
	if isOperationValid(operation) == false {
		return false
	}
	// the name of the struct field of the operation, whether its Create,Read....
	structFieldName := firstLetterToUppercase(operation)
	//case as bool
	structFieldValue, _ := getValueFromStructFieldByName(entityPermissions, structFieldName)
	if structFieldValue == nil {
		fmt.Printf("Something went wrong getting the struct field value for %s \n\n", structFieldName)
		return false
	} else {
		//Attempt to cast value as bool , since the CRUDE fields are bool
		isPermitted := structFieldValue.(bool)
		return isPermitted
	}

}

func isOperationValid(operation string) bool {
	// ensure the operation is correct
	if operation != constants.OperationCreate &&
		operation != constants.OperationRead &&
		operation != constants.OperationUpdate &&
		operation != constants.OperationDelete &&
		operation != constants.OperationExecute {
		return false
	}

	return true
}

//func getOperationFieldName(operation string)string{
//	// ensure the operation is correct
//	if isOperationValid(operation)==false{
//		return ""
//	}
//	// the name of the struct field of the operation, whether its Create,Read....
//
//	structFieldName:=""
//	switch operation {
//	case constants.OperationCreate: structFieldName:="Create"
//	break
//	case constants.OperationRead: structFieldName:="Read"
//	break
//
//	}
//}

func firstLetterToUppercase(s string) string {
	return strings.ToUpper(string(s[0])) + s[1:]

}

func getValueFromStructFieldByName(s interface{}, fieldName string) (interface{}, error) {
	rv := reflect.ValueOf(s)
	if rv.Kind() != reflect.Struct {
		return nil, fmt.Errorf("input is not a struct")
	}
	field := rv.FieldByName(fieldName)
	if !field.IsValid() {
		return nil, fmt.Errorf("field '%s' not found", fieldName)
	}
	return field.Interface(), nil
}

// if it returns -1 , it means we couldn't fetch value,
func getUintValueFromStructFieldByName(s interface{}, fieldName string) (uint,error){
	initValue, _ :=getValueFromStructFieldByName(s,fieldName)
	if initValue==nil{

		return -1,fmt.Errorf("%s is an invalid field \n",fieldName)
	}
	// attempt to cast value as int, if the assertion does not work, return -1
	uintValue,ok:=initValue.(uint)
	if !ok {

		return -1,fmt.Errorf("%s has an invalid field value \n",fieldName)
	}


	if uintValue < 0{
		// because we only want positive uint values, the return type is not uint , because I want to be able to return "-1" which denotes that getting the uint value didn't work
		return -1,fmt.Errorf("%s has an invalid field value \n",fieldName)
	}


	return uintValue,nil

}


func getStringSliceValueFromStructFieldByName(s interface{}, fieldName string) ([]string,error){
	initValue, _ :=getValueFromStructFieldByName(s,fieldName)
	if initValue==nil{

		return []string{} ,fmt.Errorf("%s is an invalid field \n",fieldName)
	}
	// attempt to cast value as []string
	stringSliceValue,ok:=initValue.([]string)
	if !ok {

		return []string{},fmt.Errorf("%s has an invalid field value \n",fieldName)
	}



	return stringSliceValue,nil

}

func getPermissionOrder(permissionOrder string) string {
	strings.TrimSpace(permissionOrder)
	// if permission is granted in one entity / order level, go to the next , if all is granted and the loop is at the last point and the last one is granted, grant permission else, deny permission
	//if permissionOrder is empty use default
	if permissionOrder == "" || len(permissionOrder) == 0 {
		permissionOrder = constants.DefaultPermissionOrder
	}
	return permissionOrder
}
func getEntityPermission(entityName string, permissionRequestData PermissionRequestData) Permission {
	var permissions Permission
	switch entityName {
	case constants.EntityOrg:
		permissions = permissionRequestData.OrgEntityPermissions
		break
	case constants.EntityDomain:
		permissions = permissionRequestData.DomainEntityPermissions
		break
	case constants.EntityGroup:
		permissions = permissionRequestData.GroupEntityPermissions
		break
	case constants.EntityRole:
		permissions = permissionRequestData.RoleEntityPermissions
		break
	case constants.EntityUser:
		permissions = permissionRequestData.UserEntityPermissions
		break
	default:
		permissions = Permission{}
		break
	}

	return permissions
}

func getEntityPermissionUsage(entityName string, usageRequestData PermissionWithUsageRequestData) PermissionUsage {
	var usage PermissionUsage
	switch entityName {
	case constants.EntityOrg:
		usage = usageRequestData.OrgEntityUsage
		break
	case constants.EntityDomain:
		usage = usageRequestData.DomainEntityUsage
		break
	case constants.EntityGroup:
		usage = usageRequestData.GroupEntityUsage
		break
	case constants.EntityRole:
		usage = usageRequestData.RoleEntityUsage
		break
	case constants.EntityUser:
		usage = usageRequestData.UserEntityUsage
		break
	default:
		usage = PermissionUsage{}
		break
	}

	return usage
}

func isEntityValid(entityName string) bool {
	// ensure the operation is correct
	if entityName != constants.EntityOrg &&
		entityName != constants.EntityDomain &&
		entityName != constants.EntityGroup &&
		entityName != constants.EntityRole &&
		entityName != constants.EntityUser {
		return false
	}

	return true
}


//TODO add a way to write this permissions in shorthand , both for obscurity and quick writing of permissions
// Then write a function to intepreter that shorthand, its basically just parsing using strings.split , you might even create your own standard of writing permissions and propose it to a body tasked with standardizing things like this
// FOllowing the unix permission pattern for each entity, you can do , "crud-","c"{all:0,batch:1,minute:0,hour:5,day:0,week:45,fortnight:0,monthly:0,quarterly:0,yearly:0,customDurations:[per_5_minutes_4,per_3_days_50]|r:....
// crud-|c=month:0,day:100,batch:1,minute:5,hour:20,week:500,fortnight:700,year:10000,quarter:5000,custom:[per_5_minutes_4,per_3_days_50]|r=
